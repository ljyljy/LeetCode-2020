package DataStructure.Union_Find;

import java.util.Arrays;
import java.util.HashSet;

public class q928_minimize_malware_spread_ii {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Arrays.sort(initial);
        int minM = n;         // 记录最少感染节点数
        int idx = initial[0]; // 记录产生最少感染节点数的 删除节点 rmIdx

        for (int init2Rm: initial) {
            // 【对比q924: q928需要删除init2Rm所在边，每轮都需重构UF】
            UnionFind uf = new UnionFind(n);
            for (int i = 0; i < n; i++) {
                if (i == init2Rm) continue; // vs-q924：完全移除init2Rm
                for (int j = i+1; j < n; j++) {
                    if (j == init2Rm) continue; // vs-q924
                    if (graph[i][j] == 1) {
                        uf.union(i, j);
                    }
                }
            }

            int curM = 0;
            HashSet<Integer> visited = new HashSet<>();
            for (int init: initial) {
                if (init == init2Rm) continue;
                int rootIdx = uf.findR(init);
                if (visited.contains(rootIdx)) continue;
                curM += uf.size[rootIdx];
                visited.add(rootIdx);
            }

            if (curM < minM) {
                minM = curM;
                idx = init2Rm;
            }
        }
        return idx;
    }

    class UnionFind {
        int[] father;
        int[] size; // 【每个连通块内的“结点总数(被感染数)”】
        int connCnt; // 连通块（可以不写）


        public UnionFind (int n) {
            father = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                father[i] = i;
            }
            Arrays.fill(size, 1); // 每个连通块内结点数（【only Root不为0】！）
            connCnt = n; // 初始化连通块 = n（全不连通）
        }

        private void union(int a, int b) {
            int rootA = findR(a), rootB = findR(b);
            if (rootA != rootB) {
                father[rootA] = rootB;
                size[rootB] += size[rootA];
                size[rootA] = 0;
                connCnt--;
            }
        }

        private int findR(int x) {
            if (x != father[x]) {
                father[x] = findR(father[x]);
            }
            return father[x]; // 不可返回x，WA!
        }

        private boolean find(int a, int b) {
            return findR(a) == findR(b);
        }
    }
}
