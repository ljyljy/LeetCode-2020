package DataStructure.Union_Find;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class q924_minimize_malware_spread {
    private int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        Arrays.sort(initial);
        int minM = n;         // 记录最少感染节点数
        int idx = initial[0]; // 记录产生最少感染节点数的 删除节点 rmIdx

        // 构建UF【q924无需重构，只需统计时将待删结点init2Rm以外的init连通块内size累加】
        // 【vs-q928：每轮都需重构，将待删结点所连通的边一并删除】
        UnionFind uf = new UnionFind(n);
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                if (graph[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }

        // 计算在删除 init2Rm 节点的条件下，有多少个节点被感染
        for (int init2Rm: initial) {
            int curM = 0; // 删除当前init2Rm结点后的 感染节点数

            // 计算重构之后的感染节点数
            Set<Integer> visited = new HashSet<>();
            for (int init: initial) {
                if (init2Rm == init) continue; // 排除当前删除的init结点【不会被感染】（init2Rm）

                int rootInit = uf.findR(init);
                if (visited.contains(rootInit)) continue;
                curM += uf.size[rootInit]; // 当前init所在连通块内的所有结点数（都被感染了）
                visited.add(rootInit);
            }
            if (minM > curM) {
                minM = curM;
                idx = init2Rm;
            }
        }
        return idx;
    }

    class UnionFind {
        int[] father;
        int[] size; // 【每个连通块内的“结点总数(被感染数)”】
        int connCnt; // 连通块（可以不写）

        public UnionFind(int n) {
            father = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                father[i] = i;
            }
            Arrays.fill(size, 1); // 每个连通块内结点数（【only Root不为0】！）
            connCnt = n; // 初始化连通块 = n（全不连通）
        }

        public void union(int a, int b) {
            int rootA = findR(a), rootB = findR(b);
            if (rootA != rootB) {  // 【勿漏！】
                father[rootA] = rootB;
                connCnt--;
                size[rootB] += size[rootA]; // 更新root(B)对应的连通块内の结点总数
                size[rootA] = 0; // size[非root(A)]=0
            }
        }

        public boolean find(int a, int b) {// 即：isConnected
            return findR(a) == findR(b);
        }

        public int findR(int x) {
            if (x != father[x]) {// 非while, TLE
                father[x] = findR(father[x]);
            }
            return father[x]; // 不可返回x，WA!
        }
    }
}
